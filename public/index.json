[{"categories":null,"content":"This article shows the basic Markdown syntax and format.","date":"2019-01-19","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"ID：张阳阳_Auuu 目前在西安这座古城辛勤搬砖 会使用不同语言编写Hello,World的一只小菜鸟 想好好搞技术，但是看啥都很吃力(太不友好了@ @ ","date":"2019-01-19","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"联系方式 QQ：937576339 Email：ma1ive@qq.com ","date":"2019-01-19","objectID":"/about/:0:1","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"其他社交 Telegram#AuuuNya Weibo LAST： 想好好学习深入一门语言 func main(){ fmt.Println(\"Hello,World!\") } ","date":"2019-01-19","objectID":"/about/:0:2","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"很久都没更新文章了，最近恰好在做了一个服务端主动推送消息给客户端的需求，因为是第一次使用Channels模块，踩了不少坑，在这里记录一下。 ","date":"2020-04-09","objectID":"/post/django%E4%BD%BF%E7%94%A8websocketchannel%E5%88%9D%E4%BD%93%E9%AA%8C/:0:0","tags":["Python","Django","Websocket","Channel"],"title":"Django使用Websocket,Channel初体验","uri":"/post/django%E4%BD%BF%E7%94%A8websocketchannel%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"什么是Websocket websocket的介绍 WebSocket-阮一峰老师 通俗的来说Websocket就是一个双向通道，客户端可以主动给服务端发消息，服务端也可以主动给客户端发送消息。 Channels是Django里面可以构建websocket的模块，官方文档里说了很清晰了，就是一个以处理WebSocket，聊天协议，IoT协议的模块，基于称为ASGI的Python规范构建。它可以以异步的方式进行。 ","date":"2020-04-09","objectID":"/post/django%E4%BD%BF%E7%94%A8websocketchannel%E5%88%9D%E4%BD%93%E9%AA%8C/:0:1","tags":["Python","Django","Websocket","Channel"],"title":"Django使用Websocket,Channel初体验","uri":"/post/django%E4%BD%BF%E7%94%A8websocketchannel%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"安装配置 python2: pip install -U channels python3: pip3 install -U channels # 添加到yourproject.settings INSTALLED_APPS = ( 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.sites', ... 'channels', ) # yourproject/routing.py from channels.routing import ProtocolTypeRouter application = ProtocolTypeRouter({ # Empty for now (http-\u003edjango views is added by default) }) # 修改settings文件，yourproject/settings,添加下面一行内容 ASGI_APPLICATION = \"yourproject.routing.application\" 启用之后，通道就会将自己集成到Django中，并控制runserver命令 # 启动之后命令行变成 ASGI/channels Starting ASGI/Channels version 2.4.0 development server at https://127.0.0.1:8000/ 下面是在实际中编写的一个模块，主要用websocket连接通道，然后服务端主动推送消息.聊天室的例子大家可以在网上搜一下有很多，我在这里就不多做描写了。 # 目录结构 yourproject/ - yourproject/ - asgi.py - routing.py - wsgi.py - settings.py - urls.py - chat/ - routing.py - consumers.py - controller.py - manage.py # youproject/routing.py from channels.routing import ProtocolTypeRouter, URLRouter from django.conf.urls import url from chat import routing application = ProtocolTypeRouter({ # 没有做权限校验 \"websocket\": URLRouter( chat.routing.websocket_urlpatterns ) }) # chat/routing.py from django.conf.urls import re_path from monitor.consumers import AsyncConsumer websocket_urlpatterns = [ # api router setting re_path(r'ws/chat/', AsyncConsumer) ] # 官方文档一般建议使用AsyncWebsocketConsumer # 原文默认情况下编写SyncConsumers，并且仅在以下情况下使用AsyncConsumers：通过异步处理来改善的事情 # 如果想要在其他模块主动推送消息给客户端，必须使用通道，通道分为Redis和内存通道（生产中不建议使用） # 配置通道层 # yourproject/settings.py CHANNEL_LAYERS = { \"default\": { \"BACKEND\": \"channels_redis.core.RedisChannelLayer\", \"CONFIG\": { \"hosts\": [(\"127.0.0.1\", 6379)], }, }, } # chat/consumers.py from channels.generic.websocket import AsyncWebsocketConsumer from monitor import CHANNEL_NAME from redis_cache import REDIS_CONN import json class AsyncConsumer(AsyncWebsocketConsumer): async def connect(self): \"\"\" 连接时触发 并且分配一个self.channel_name名称可以存数据库 这里我存入redis 主要方便 \"\"\" REDIS_CONN.lpush(CHANNEL_NAME, self.channel_name) await self.accept() # Receive message from WebSocket async def receive(self, text_data=None, bytes_data=None): # text_data_json = json.loads(text_data) # message = text_data_json['message'] # 接受信息并回复 await self.send(text_data = json.dumps(text_data)) async def disconnect(self, close_code): # 将关闭的连接从群组中移除 results = REDIS_CONN.lrange(CHANNEL_NAME, 0, REDIS_CONN.llen(CHANNEL_NAME)) for index, item in enumerate(results): if self.channel_name == item: REDIS_CONN.lrem(CHANNEL_NAME, index, item) await self.close() # 主动推送的事件处理方法 async def push_message(self, event): data = json.dumps(event[\"text\"]) await self.send(text_data = data) # chat/controller.py from channels.layers import get_channel_layer from asgiref.sync import async_to_sync from monitor import CHANNEL_NAME from redis_cache import REDIS_CONN # 官方例子，异步推送消息 channel_layer = get_channel_layer() await channel_layer.send(\"channel_name\", { \"type\": \"chat.message\", \"text\": \"Hello there!\", }) # 同步推送消息，调用函数即可推送 def push_chat_message(data): \"\"\" 从redis拿到已经连接的通道名称 \"\"\" channel_layer = get_channel_layer() # 循环redis中的channel_name，并且推送消息 results = REDIS_CONN.lrange(CHANNEL_NAME, 0, REDIS_CONN.llen(CHANNEL_NAME)) for channel in results: async_to_sync(channel_layer.send)(channel, { # consumer中的事件处理方法,建议为事件类型加上前缀如`push.`避免冲突. \"type\": \"push.message\", \"text\": data, } ) 以上就是单通道推送消息的例子，第一次使用也有很多地方不清楚，这块只是做个记录，根据网上看到的一些资料，再总结一下。如果想要了解聊天室的例子，大家可以去网上搜一下，有很多，官方文档也有chan_examplte.还望大佬们轻拍. ","date":"2020-04-09","objectID":"/post/django%E4%BD%BF%E7%94%A8websocketchannel%E5%88%9D%E4%BD%93%E9%AA%8C/:0:2","tags":["Python","Django","Websocket","Channel"],"title":"Django使用Websocket,Channel初体验","uri":"/post/django%E4%BD%BF%E7%94%A8websocketchannel%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":null,"content":"眨眼就到2020年了,不由得感慨时间过得真快,回想这一年来发生的事,那可真谓是丰富多彩,多滋多味.(不知道18年立的Flag实现了多少???) 成长不少,难过也不见得少…… ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:0","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"时间飞快 19/01.05：好朋友结婚,做伴郎 19/02.20：去往成都游玩了几天 怀疑了自己三个月 19/05.01：入职新公司,区块链安全行业,主要做后台开发 19/07.01：入职后的第一个项目试运营,不过此时的水平能自己一个人单独做出来前后端已经很不错了 19/09：公司搬家,并且第一个团建,大家一起吃了个饭,此时已经开始慢慢融入团队 19/10中：招进来前端妹子,UI妹子(终于不是一群大老爷们了^ ^~ 19/11初：此时觉得自己很牛,开始不再考虑业务上的东西,都去看什么所谓的高端技术了(这个时候是真2逼~~ 19/11.01：和四叶草团队一起团建,爬了一次秦岭 19/12初：调整状态 19/12中：开始尝试更多东西,做自己喜欢做的事 ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:1","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"流水账  这一年确实挺丰富,一月份认识十几年的好友兼技术大佬结婚,有幸当了一回伴郎,和非正常人类研究中心的小伙伴们见了一面,坐在一起来了几把开心五黑,辅助莫甘娜带飞四个菜,闹伴郎那天着实有点开心.后来挺后悔之前没有出去外面工作.  二月份的时候有天晚上在一块喝酒,桌上有个友人随口说了一句不如我们去成都玩一次.于是当晚拍板买了去成都的票,什么计划也没有做,第二天匆匆去北站坐车赶去了成都.在成都这几天可真是火辣辣的生活,天天都是火锅.- -.以至于我现在看到太辣的东西都不想动筷子.两天半的时间我们去了宽窄巷子、春熙路、大熊猫繁育基地,晚上去了一次酒吧街,不过没有进去消费,也不知道是怕啥?…  回来之后消失了一段时间.沉迷了一段时间.每天都过的非常焦虑,天天怀疑自己.也挺感谢在这段时间帮助过我的朋友,由衷的感谢.  四月下旬的时候与邓哥和琨哥聊的时候都感觉到挺合拍,于是五月份入职.一开始的时候挺怀疑自己,接手的项目是一套后端用的Python,前端用的Vue.自己一个人在哪琢磨修改了差不多两个多月吧,搞完.在这期间是真的觉得自己技术成长了,并且顺利学会了Vue……  接下来的日子就是守规守据的度过一天又一天的工作,期间招过一个前端,结果确定了入职后,前端回家结婚了- -,然后又是我自己在那依靠着我这仅有的一丝审美去做一些前端上的事情.这段时间在前端方向的道路是越走越远,有点迷幻.  九月份公司搬家了,之后工作效率感到明显的提升,多多少少做了五/六个项目,基本都是Go + Vue前后端分离.估计也是心态膨胀了,听到需求之后就直接上手撸代码,没有好好梳理过自己的思路,没有考虑过如果去构思一个项目的框架,包括注释也是写的乱七八糟,没有一个好的规范.那几天满脑子骚操作什么RPC 微服务 并发啥的,现在想想都没多少用户,考虑那么多干啥,真2逼~.于是在做完这几个项目之后,恰好公司招进来几个伙伴.然后自己更多的是考虑微小功能的实现点,去思考业务原型,在某个业务模块停留很长时间,去尝试十几遍,怎么修改它会提升效率,或者让代码看起来更美观一点.  十一月份和四叶草的小伙伴一起爬了一次秦岭,早晨八点去,晚上十点回.累也开心.  emmmmmm…这段时间删掉 祝万事胜意.  十二月份是一个繁忙的月份,一小半在工作,一大半在生活…去听了辉子的LiveHouse,现场听了,去了两三次漫巷,买了一些书回来看,在南门LEGO店,买了一盒乐高,熬夜拼了三个小时.看了几场电影,强推《触不可及》,美版/法版都推给你们.买了一根横笛本来想买唢呐怕扰民,不过买回来还没吹过一次,看来要找时间学学.这个月萌发了很多奇奇怪怪的想法,谢谢那些能陪我去尝试的人,感谢我身边出现的每个人,每位朋友.  雪融化之后,是春天 ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:2","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"阅读 没读完的也算里面… 《设计模式》 《Python基础教程》 《Vue实战》 《Go程序设计语言》 《PythonWeb学习开发》 《HTML5/CSS3开发实战》 《禅者的初心》 《天才在左，疯子在右》 《流言》 -张爱玲 《重返边城》 -张爱玲 《看过无数的云，却只爱过一个你》 -沈从文 《沈从文自传》 -沈从文 ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:3","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"电影 这一年看过的电影太多了,除过影院上映过的,我就推一些我觉得有必要多看几遍的电影 《触不可及》 《万箭穿心》 《我们俩》 《失孤》 《守望者》 《亲爱的,不要跨过那条江》 《好兆头》 《诺丁山》 《真爱至上》 《天空之上三公尺》 《海蒂与爷爷》 另外一提,漫威宇宙太强了,国内的动漫也崛起了,国漫加油.内心os：I Like BiliBili. ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:4","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"工作  没有在学习什么新的技术,更多的是业务水平方向的成长,能更好的去从一个用户的方向去理解某个功能模块的作用,和同事配合方向更默契了,在细节上下的功夫比较多.要说学习的话,成功转型成了前端算不算… ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:5","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"感情  你好,我姓张 ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:6","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"遗憾  腹肌没有达到八块,好气!!!!! ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:7","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"我又来立新的Flag了!!! 学习(学个屁 ' _ ' React,Redux Docker,K8s 看看微服务 Java,Go 数据库相关 重心主要放在后端 生活 看完目前手上的书 学会一种乐器 培养自己的审美 拥有自己的穿衣风格 养成健康的生活行为 其他 遇到好的电影一定会去看 去自己喜欢的演出现场 旅游 ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:8","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"总结  2020年希望可以把工作和生活融合在一起,去尝试自己脑海里的想法. 向之前的自己说声辛苦了, ","date":"2020-01-07","objectID":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/:0:9","tags":["生活"],"title":"2019的一些琐事","uri":"/post/2019%E5%B9%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%90%E4%BA%8B/"},{"categories":null,"content":"最新在修改一个用户中心，前台是用Vue+Nuxt+ElementUI写的，在修改过程中发现不管样式怎么写，加父标签，elementui加载都会使用它自己的样式，于是看了看代码， 在这里记录下我是怎么修改它的默认样式的。 例如：这是一段Tabs选项卡组建的代码 \u003ctemplate\u003e \u003cel-tabs v-model=\"activeName\" @tab-click=\"handleClick\"\u003e \u003cel-tab-pane label=\"用户管理\" name=\"first\"\u003e用户管理\u003c/el-tab-pane\u003e \u003cel-tab-pane label=\"配置管理\" name=\"second\"\u003e配置管理\u003c/el-tab-pane\u003e \u003cel-tab-pane label=\"角色管理\" name=\"third\"\u003e角色管理\u003c/el-tab-pane\u003e \u003cel-tab-pane label=\"定时任务补偿\" name=\"fourth\"\u003e定时任务补偿\u003c/el-tab-pane\u003e \u003c/el-tabs\u003e \u003c/template\u003e 它在编译后生成的代码 \u003cdiv class=\"el-tabs el-tabs--top\"\u003e \u003cdiv class=\"el-tabs__header is-top\"\u003e \u003cdiv class=\"el-tabs__nav-wrap is-top\"\u003e \u003cdiv class=\"el-tabs__nav-scroll\"\u003e \u003cdiv role=\"tablist\" class=\"el-tabs__nav is-top\" style=\"transform: translateX(0px);\"\u003e ...... \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"el-tabs__content\"\u003e ...... \u003c/div\u003e \u003c/div\u003e 然后打开页面，打开开发者工具，查看生成编译后的代码，它会带有一些默认class属性名，然后我们可以在Chrome调整它的样式，觉得可以了连带class属性名复制到组建里面的\u003cstyle\u003e\u003c/style\u003e里面,如果要修改相同的样式后面一定要加!important，不然它是不会重写这个样式的. 例如: # 修改前 .el-tabs el-tabs--top{ background:#eee; } # 修改后 .el-tabs el-tabs--top{ border:1px solid #eee; // 默认样式没有的属性 background:#fff !important; } 在网上还看到有人说关于\u003cstyle\u003e后面要不要加scoped这个属性，在官方看了一下这个属性是关于全局和局部渲染的选项，加了之后你组建的样式只会渲染你当前组建里面的样式，不加的话，其他地方也用到这个样式的话，会对你当前组建有一定的影响，当然如果你全局样式也改得和局部一样的话，那么影响是不存在的。 ","date":"2019-05-21","objectID":"/post/element-ui%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F/:0:0","tags":["Vue","ElementUI"],"title":"Element UI修改默认样式","uri":"/post/element-ui%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F/"},{"categories":null,"content":"Friends Tuuu Nya's Blog 4uuu Nya's Blog Nuuu Nya's Blog Muuu Nya's Blog Ruuu Nya's Blog Mosuan's Blog 谭师傅 云谷计算 X0chitl's Blog TMazie's Blog ","date":"2019-01-19","objectID":"/links/:0:1","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"Groups MooFish摸鱼俱乐部 安全盒子 ","date":"2019-01-19","objectID":"/links/:0:2","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"博客从Jekyll迁移到了Hugo，主题为next主题改了一些东西。 ","date":"2019-01-17","objectID":"/post/first/:0:0","tags":["Hugo"],"title":"Hello Hugo","uri":"/post/first/"},{"categories":null,"content":"本地端口映射 小明写了一个Web服务，监听hosta上8080端口，小王现在想访问这个服务，有没有快速的方法? 其实很简单，小明只需要做这两件事情： 申请一台带公网IP的公有云服务器hostb，我们假设ip地址是12.34.56.78 在hosta上执行下面的命令，它会建立一个从hosta到hostb的ssh会话，同时将8080端口映射到hostb的1080端口。 ssh -R 1080:localhost:8080 root@12.34.56.78\r 这样，小王就可以愉快的用http://12.34.66.78:1080访问小明的服务了。 远程Unix Socket映射 除了将我们本地服务通过端口映射提供给其它人访问，我们还可以通过端口转发玩一些更high的。比如下面这条命令，它把监听在远程主机12.34.56.78上的mysql服务unix socket映射到本地的/var/run/mysqld.temp.sock，这样，小明就可以用mysql -S /var/run/mysqld/mysqld.temp.sock来访问远程主机的mysql服务了。 socat \"UNIX-LISTEN:/var/run/mysqld.temp.sock,reuseaddr,fork\" EXEC:\"ssh root@12.34.56.78 socat STDIO UNIX-CONNECT:/var/run/mysqld/mysqld.sock\"\r 当然，小明如果不喜欢本地unix socket，他还可以用下面的命令把12.34.56.78上的mysql映射到本地的5500端口，然后使用mysql -p 5500命令访问。 socat TCP-LISTEN:5500 EXEC:'ssh root@12.34.56.78 \"socat STDIO UNIX-CONNECT:/var/run/mysqld/mysqld.sock\"'\r UDP也不在话下，比如下面这条命令可以把12.34.56.78的udp 161端口映射到本地的1611端口： socat udp-listen:1611 system:'ssh root@12.34.56.78 \"socat stdio udp-connect:remotetarget:161\"'\r ","date":"2019-01-02","objectID":"/post/2019-1-02-%E7%94%A8ssh%E5%92%8Csocat%E5%88%86%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9Alinux%E5%90%84%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/:0:1","tags":["linux","SSH"],"title":"用ssh和socat分分钟搞定Linux各种端口转发","uri":"/post/2019-1-02-%E7%94%A8ssh%E5%92%8Csocat%E5%88%86%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9Alinux%E5%90%84%E7%A7%8D%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"categories":null,"content":"今天为大家带来一篇用Go如何封装自己的日志模块。orz~ 既然是日志模块，第一步肯定是定义日志级别，不然什么消息都打印，对资源消耗很大。 这里使用iota常量计数器定义了四个级别,使用iota能简化定义，在定义枚举时很有用。 ### 定义日志级别\rconst (\rLevelError = iota\rLevelWarning\rLevelInfo\rLevelDebug\r)\r//定义日志结构体\rtype logging struct {\rlevel int\rfile *os.File\r}\r//定义logging类型变量\rvar logFile logging\r 等级设置我们使用了一个函数.参数必须为int类型 func setLevel(level int) {\rlogFile.level = level\r}\r ","date":"2018-06-09","objectID":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/:0:0","tags":["golang"],"title":"用Go编写封装自己的日志模块","uri":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"初始化 //Logger类型表示一个活动状态的记录日志的对象，它会生成一行行的输出写入一个io.Writer接口。\r//每一条日志操作会调用一次io.Writer接口的Write方法。Logger类型的对象可以被多个线程安全的同时使用，它会保证对io.Writer接口的顺序访问。\rvar loggerf *log.Logger\r//初始化\rfunc init() {\r//初始化级别为LevelDebug\r logFile.level = LevelDebug\r//这块直接 log.New\r //创建一个Logger。参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性(时间、文件等等)\r //`prefix`在这块留空，下面输出函数可以设置为级别,减少了代码的冗杂\r loggerf = log.New(os.Stdout, \"\", log.Llongfile|log.Ltime|log.Ldate)\r}\r ","date":"2018-06-09","objectID":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/:0:1","tags":["golang"],"title":"用Go编写封装自己的日志模块","uri":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"输出函数定义 //获取当前函数所在的路径，文件名和行号\r// func CallerFunc() string {\r// filename, file, line, ok := runtime.Caller(0)\r// if !ok {\r// return \"\"\r// }\r// return \"FileName:\" + runtime.FuncForPC(filename).Name() + \" Path:\" + file + \" Line:\" + strconv.Itoa(line)\r// }\r// 当时`info`级别想要输出文件名，路径，错误行号等用了上面的函数，结果周师傅说，`log`包里面有个New函数，里面可以直接定义上面需要的信息\r//按照格式打印日志\rfunc Debugf(format string, v ...interface{}) {\rif logFile.level \u003e= LevelDebug {\r//log里的函数都自带有mutex\r //这里获取一次锁\r loggerf.Printf(\"[DEBUG] \"+format, v...)\r}\r}\r//Infof\rfunc Infof(format string, v ...interface{}) {\rif logFile.level \u003e= LevelInfo {\rloggerf.Printf(\"[INFO] \"+format, v...)\r}\r}\r//Warningf\rfunc Warningf(format string, v ...interface{}) {\rif logFile.level \u003e= LevelWarning {\rloggerf.Printf(\"[WARNING] \"+format, v...)\r}\r}\r//Errorf\rfunc Errorf(format string, v ...interface{}) {\rif logFile.level \u003e= LevelError {\rloggerf.Printf(\"[ERROR] \"+format, v...)\r}\r}\r//标准输出\r//Println存在输出会换行\r//这里采用Print输出方式\rfunc Debug(v ...interface{}) {\rif logFile.level \u003e= LevelDebug {\rloggerf.Print(\"[DEBUG] \" + fmt.Sprintln(v...))\r}\r}\r//Info\rfunc Info(v ...interface{}) {\rif logFile.level \u003e= LevelInfo {\rloggerf.Print(\"[INFO] \" + fmt.Sprintln(v...))\r}\r}\r//Warning\rfunc Warning(v ...interface{}) {\rif logFile.level \u003e= LevelWarning {\rloggerf.Print(\"[DEBUG] \" + fmt.Sprintln(v...))\r}\r}\r//Error\rfunc Error(v ...interface{}) {\rif logFile.level \u003e= LevelError {\rloggerf.Print(\"[DEBUG] \" + fmt.Sprintln(v...))\r}\r}\r ","date":"2018-06-09","objectID":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/:0:2","tags":["golang"],"title":"用Go编写封装自己的日志模块","uri":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"输出到文件 //获取当前程序所在的路径\rfunc getwd() (string, error) {\rpath, err := os.Getwd()\rif err != nil {\rreturn \"\", errors.New(fmt.Sprintln(\"Getwd Error:\", err))\r}\rfilepathstr := filepath.Join(path, \"logs\")\rerr = os.MkdirAll(filepathstr, 0755)\rif err != nil {\rreturn \"\", errors.New(fmt.Sprintln(\"Create Dirs Error:\", err))\r}\rreturn filepathstr, nil\r}\r//创建日志文件\r//制定创建路径和日志名\rfunc Init(path, logname string, level int) error {\rif path == \"\" {\rfilePath, _ := getwd()\rfilepathstr := filepath.Join(filePath, logname)\rlogfile, err := os.Create(filepathstr)\rif err != nil {\rreturn errors.New(fmt.Sprintln(\"Create File Error:\", err))\r}\rlogFile.file = logfile\rsetLevel(level)\r} else if logname == \"\" {\rfilepathstr := path\rerr := os.MkdirAll(filepathstr, 0644)\rif err != nil {\rreturn errors.New(fmt.Sprintln(\"Create Dirs Error:\", err))\r}\rlogname = filepath.Join(filepathstr, \"logs.log\")\rlogfile, err := os.Create(logname)\rif err != nil {\rreturn errors.New(fmt.Sprintln(\"Create File Error:\", err))\r}\rlogFile.file = logfile\rsetLevel(level)\r} else {\rfilepathstr := path\rerr := os.MkdirAll(filepathstr, 0644)\rif err != nil {\rreturn errors.New(fmt.Sprintln(\"Create Dirs Error:\", err))\r}\rlogname = filepath.Join(filepathstr, logname)\rlogfile, err := os.Create(logname)\rif err != nil {\rreturn errors.New(fmt.Sprintln(\"Create File Error:\", err))\r}\rlogFile.file = logfile\rsetLevel(level)\r}\r//log.Llongfile|log.Ltime|log.Ldata 返回文件信息，时间和代码信息不需要重新写函数获取\r //初始化一个*log.Logger\r loggerf = log.New(logFile.file, \"\", log.Llongfile|log.Ltime|log.Ldate)\rreturn nil\r}\r 以上代码大家可以再整合或者再次封装，可能会更方便快捷。我这里只是提供了一个我自己在封装日志模块所考虑的地方与最后的思路. 详细代码地址 ","date":"2018-06-09","objectID":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/:0:3","tags":["golang"],"title":"用Go编写封装自己的日志模块","uri":"/post/2018-06-09-%E7%94%A8go%E7%BC%96%E5%86%99%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"},{"categories":null,"content":"最近要在dingo添加一个功能，就是一键导出文章静态页面，在网上搜了很多，也请教了很多人，不过碍于自己的技术太菜听不怎么太明白，后来搜到一片文章，借用此篇文章和自己的一些测试终究是完成了这个功能。 文章作者写的生成器git地址:blog-generator ","date":"2018-05-09","objectID":"/post/2018-05-09-golang%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6/:0:0","tags":["golang"],"title":"Golang生成静态页面文件","uri":"/post/2018-05-09-golang%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"定义要渲染的模板路径 func getTemplate() (*template.Template, error) {\rpath, err := os.Getwd()\rif err != nil {\rfmt.Errorf(\"Path is Error\")\r}\r#使用filepath包把当前路径和模板路径拼接在一起\rtemplatePath := filepath.Join(path, \"staticPost\", \"template.html\")\rt := template.New(\"template.html\")\rt, err = t.ParseFiles(templatePath)\rif err != nil {\rreturn nil, fmt.Errorf(\"error reading template %v\", err)\r}\rreturn t, nil\r}\r 上面代码定义好要渲染的模板，如果有模板函数可以在template.New()后面Funcs注入模板函数 ","date":"2018-05-09","objectID":"/post/2018-05-09-golang%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6/:0:1","tags":["golang"],"title":"Golang生成静态页面文件","uri":"/post/2018-05-09-golang%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"根据文章名称保存 func WriteIndexHTML(name string, post *model.Post) error {\rt, err := getTemplate()\rpath, _ := os.Getwd()\r#当时想一次创建好，结果发现os.create不能创建目录，所以又用mkdirall创建好所需要的目录\rerr = os.MkdirAll(filepath.Join(path, \"staticPost\", \"PostsView\", name), 0777)\rif err != nil {\rpanic(err)\r}\r#根据文章名称保存到指定路径\rfilePath := filepath.Join(path, \"staticPost\", \"PostsView\", name, \"index.html\")\r#创建文章\rf, err := os.Create(filePath)\rif err != nil {\rreturn fmt.Errorf(\"error creating file %s: %v\", filePath, err)\r}\rdefer f.Close()\rw := bufio.NewWriter(f)\r#td 是我想要传送给前台需要渲染的文章参数\rtd := map[string]interface{}{\r\"Title\": post.Title,\r\"Post\": post,\r\"Content\": post,\r}\rif err := t.Execute(w, td); err != nil {\rreturn fmt.Errorf(\"error executing template %s: %v\", filePath, err)\r}\rif err := w.Flush(); err != nil {\rreturn fmt.Errorf(\"error writing file %s: %v\", filePath, err)\r}\rreturn nil\r}\r 当时看上面大佬的写的代码有些复杂，有很多细节都写到了。在这块我只是简单把需要用的代码抠出来再做一次简化，如果有兴趣可以去看看上面git，做这个功能在网上泡了好几天，一直没有头绪，看了代码之后也就1~2个小时就把90%写出来了。 ","date":"2018-05-09","objectID":"/post/2018-05-09-golang%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6/:0:2","tags":["golang"],"title":"Golang生成静态页面文件","uri":"/post/2018-05-09-golang%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6/"},{"categories":null,"content":" SSL 证书X.509 是国际电信联盟电信标准化部门（ ITU-T ）为公钥基础设施制定的一个标准，这个标准包含了公钥证书的标准格式。 一个 X.509 证书（简称 SSL 证书）实际上就是一个经过编码的 ASN.1( Abstract Syntax Notation One,抽象语法表示法／1 ）格式的电子文档。 ASN.1 既是一个标准，也是一种表示法，它描述了表示电信以及 计算机网络数据的规则和结构。 X.509 证书可以使用多种格式编码，其中一种编码格式是 BER ( Basic Encoding Rules ，基本编码规 则）。 BER 格式指定了一种自解释并且自定义的格式用于对 ASN.1 数据结构进行编码，而 DER 格式则是 BER 的一个子集。 DER 只提供了一种编码 ASN.1 值的方法，这种方法被广泛地应用于密码学当中，尤其是对 X.509 证书进行加密。56 第 3 章接收请求SSL 证书可以以多种不同的格式保存，其中一种是 PEM (Privacy Enhanced Email ，隐私增强邮件 ）格式，这种格式会对 DER 格式的 X.509 证书实施Base64 编码，并且这种格式的文件都以一一BEGINCERTIFICATE一开头，以一一END CERTIF工CATE一结尾｛除了用作文件格式之外 ， PEM和此处讨论的 SSL 证书关系并不大）。 生成证书的方法并不复杂,因为 SSL 证书实际上就是一个将扩展密钥用 法（extended key usage）设置成了服务器身份验证操作的X.509证书 ","date":"2018-04-20","objectID":"/post/2018-04-20-golang%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%81%E9%92%A5/:0:0","tags":["golang"],"title":"Golang生成SSL证书以及服务器私钥","uri":"/post/2018-04-20-golang%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%81%E9%92%A5/"},{"categories":null,"content":"配置证书信息 //生成一个比较长的随机整数来做序列号\rmax := new(big.Int).Lsh(big.NewInt(1), 128)\rseriaNumber := rand.Int(rand.Reader, max)\r//生成证书标题\rsubject := pkix.Name{\rOrganization: []string{\"Mu1er.cn\"},\rOrganizationalUnit: []string{\"mu1er\"},\rCommonName: \"mu1er.cn\",\r}\rtemplate := x509.Certificate{\rSerialNumber: seriaNumber,\rSubject: subject,\rNotBefore: time.Now(),\r//有效期\r NotAfter: time.Now().Add(365 * 24 * time.Hour),\r//用x509证书来验证\r KeyUsage: x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\rExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\r//运行地址\r IPAddresses: []net.IP{net.ParseIP(\"127.0.0.1\")},\r}\r ","date":"2018-04-20","objectID":"/post/2018-04-20-golang%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%81%E9%92%A5/:0:1","tags":["golang"],"title":"Golang生成SSL证书以及服务器私钥","uri":"/post/2018-04-20-golang%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%81%E9%92%A5/"},{"categories":null,"content":"生成 RSA 私钥 pk, _ := rsa.GenerateKey(rand.Reader, 2048)\r 私钥结构里面包含了一个能够公开访问的公钥，随后创建SSL证书的时候会用到 derBytes, _ := x509.CreateCertificate(rand.Reader, \u0026template, \u0026template,\u0026pk.PublicKey, pk)\r CreateCertificate函数接受Certificate结构、公钥和私钥等多个参数，创建出一个经过 DER 编码格式化的字节切片 。后续代码的意图也非常简单明了，它们首先使用encoding/pem标准库将证书编码到cert.pem文件里面 certOut, _ := os.Create(\"cert.pem\")\rpem.Encode(certOut, \u0026pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes})\rcertOut.Close()\r 然后继续以 PEM 编码的方式把之前生成的密钥编码并保存到key.pem文件里面： keyOut, _ := os.Create(\"key.pem\")\rpem.Encode(keyOut, \u0026pem.Block{Type: \"RSA PRIVATE KEY\", Bytes: x509.MarshalPKCS1PrivateKey(pk)})\rkeyOut.Close()\r 最后需要提醒的是，如果证书是由CA签发的，那么证书文件中将同时包含服务器签名以及CA签名，其中服务器签名在前,CA签名在后. ","date":"2018-04-20","objectID":"/post/2018-04-20-golang%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%81%E9%92%A5/:0:2","tags":["golang"],"title":"Golang生成SSL证书以及服务器私钥","uri":"/post/2018-04-20-golang%E7%94%9F%E6%88%90ssl%E8%AF%81%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A7%81%E9%92%A5/"},{"categories":null,"content":"AJAX中请求远端文件、或在检测远端文件是否掉链时，都需要了解到远端服务器反馈的状态以确定文件的存在 与否。 当然，在我们平常浏览网页时，也会发现一些文件不存在时显示为“404错误”，这就是常见的Http请求状态（status） Web服务器响应浏览器或其他客户程序的请求时，其应答一般由以下几个部分组成：一个状态行，几个应答头，一个空行，内容文档。下面是一个最简单的应答： 状态行包含HTTP版本、状态代码、与状态代码对应的简短说明信息。在大多数情况下，除了Content-Type之外的所有应答头都是可选的。但Content-Type是必需的，它描述的是后面文档的MIME类型。虽然大多数应答都包含一个文档，但也有一些不包含，例如对HEAD请求的应答永远不会附带文档。有许多状态代码实际上用来标识一次失败的请求，这些应答也不包含文档（或只包含一个简短的错误信息说明）。 当用户试图通过 HTTP 访问一台正在运行 Internet 信息服务 (IIS) 的服务器上的内容时，IIS 返回一个表示该请求的状态的数字代码。状态代码可以指明具体请求是否已成功，还可以揭示请求失败的确切原因。 ","date":"2018-04-05","objectID":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/:0:0","tags":["HTTP"],"title":"XMLHTTPRequest状态status完整列表","uri":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"1xx - 信息提示 这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个 1xx 响应。 0 - 本地响应成功。 100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） ","date":"2018-04-05","objectID":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/:0:1","tags":["HTTP"],"title":"XMLHTTPRequest状态status完整列表","uri":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"2xx - 成功 这类状态代码表明服务器成功地接受了客户端请求。 200 - OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 - Created 服务器已经创建了文档，Location头给出了它的URL。 202 - Accepted 已经接受请求，但处理尚未完成。 203 - Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息（HTTP 1.1新）。 204 - No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 - Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 - Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 ","date":"2018-04-05","objectID":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/:0:2","tags":["HTTP"],"title":"XMLHTTPRequest状态status完整列表","uri":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"3xx - 重定向 客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 300 - Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 - Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 - Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求 http://host/~user （缺少了后面的斜杠），有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 - See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 - Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 - Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 - Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新） ","date":"2018-04-05","objectID":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/:0:3","tags":["HTTP"],"title":"XMLHTTPRequest状态status完整列表","uri":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"4xx - 客户端错误 发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。 400 - Bad Request 请求出现语法错误。 401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。IIS 定义了许多不同的 401 错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在 IIS 日志中显示： 401.1 - 登录失败。 401.2 - 服务器配置导致登录失败。 401.3 - 由于 ACL 对资源的限制而未获得授权。 401.4 - 筛选器授权失败。 401.5 - ISAPI/CGI 应用程序授权失败。 401.7 – 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。 403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。禁止访问：IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因： 403.1 - 执行访问被禁止。 403.2 - 读访问被禁止。 403.3 - 写访问被禁止。 403.4 - 要求 SSL。 403.5 - 要求 SSL 128。 403.6 - IP 地址被拒绝。 403.7 - 要求客户端证书。 403.8 - 站点访问被拒绝。 403.9 - 用户数过多。 403.10 - 配置无效。 403.11 - 密码更改。 403.12 - 拒绝访问映射表。 403.13 - 客户端证书被吊销。 403.14 - 拒绝目录列表。 403.15 - 超出客户端访问许可。 403.16 - 客户端证书不受信任或无效。 403.17 - 客户端证书已过期或尚未生效。 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。 404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答。 404.0 -（无） – 没有找到文件或目录。 404.1 - 无法在所请求的端口上访问 Web 站点。 404.2 - Web 服务扩展锁定策略阻止本请求。 404.3 - MIME 映射策略阻止本请求。 405 - Method Not Allowed请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用，用来访问本页面的 HTTP 谓词不被允许（方法不被允许）（HTTP 1.1新） 406 - Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容，客户端浏览器不接受所请求页面的 MIME 类型（HTTP 1.1新）。 407 - Proxy Authentication Required 要求进行代理身份验证，类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 - Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新） 409 - Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 - Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 - Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 - Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。 413 – Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 - Request URI Too Long URI太长（HTTP 1.1新）。 415 – 不支持的媒体类型。 416 – Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 417 – 执行失败。 423 – 锁定的错误。 ","date":"2018-04-05","objectID":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/:0:4","tags":["HTTP"],"title":"XMLHTTPRequest状态status完整列表","uri":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"5xx - 服务器错误 服务器由于遇到错误而不能完成该请求。 500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 500.12 - 应用程序正忙于在 Web 服务器上重新启动。 500.13 - Web 服务器太忙。 500.15 - 不允许直接请求 Global.asa。 500.16 – UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。 500.18 – URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。 500.100 - 内部 ASP 错误。 501 - Not Implemented 服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的PUT请求。 502 - Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说Web 服务器用作网关或代理服务器时收到了无效响应。 502.1 - CGI 应用程序超时。 502.2 - CGI 应用程序出错。 503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。这个错误代码为 IIS 6.0 所专用。 504 - Gateway Timeout 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）。 505 - HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。 ","date":"2018-04-05","objectID":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/:0:5","tags":["HTTP"],"title":"XMLHTTPRequest状态status完整列表","uri":"/post/2018-4-4-xmlhttprequest%E7%8A%B6%E6%80%81status%E5%AE%8C%E6%95%B4%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"原文链接：http://t.cn/RzCP9E2 作者输入命令时都用“sudo bash”，用sudo或者su就可以了。 涉及到磁盘分区表删除，最好先备份整个虚拟机！ ","date":"2018-03-27","objectID":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/:0:0","tags":["linux"],"title":"VMware下扩展ubuntu虚拟机根目录分区","uri":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/"},{"categories":null,"content":"检查文件系统： cruz@ubuntu:~$ sudo bash\r[sudo] password for cruz: root@ubuntu:~# df -h\rFilesystem Size Used Avail Use% Mounted on\r/dev/sda1 9.0G 2.7G 5.9G 32% /\rudev 488M 4.0K 488M 1% /dev\rtmpfs 199M 800K 198M 1% /run\rnone 5.0M 0 5.0M 0% /run/lock\rnone 497M 76K 496M 1% /run/shm\rroot@ubuntu:~# ","date":"2018-03-27","objectID":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/:0:1","tags":["linux"],"title":"VMware下扩展ubuntu虚拟机根目录分区","uri":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/"},{"categories":null,"content":"检查磁盘分区表： root@ubuntu:~# fdisk -l /dev/sda\rDisk /dev/sda: 10.7 GB, 10737418240 bytes\r255 heads, 63 sectors/track, 1305 cylinders, total 20971520 sectors\rUnits = sectors of 1 * 512 = 512 bytes\rSector size (logical/physical): 512 bytes / 512 bytes\rI/O size (minimum/optimal): 512 bytes / 512 bytes\rDisk identifier: 0x00001dec\rDevice Boot Start End Blocks Id System\r/dev/sda1 * 2048 18874367 9436160 83 Linux\r/dev/sda2 18876414 20969471 1046529 5 Extended\r/dev/sda5 18876416 20969471 1046528 82 Linux swap / Solaris\rroot@ubuntu:~# 记住上面显示的交换分区大小（Blocks的数目），这里就是1046528。如果交换分区和根目录不在一个磁盘(比如/dev/sdb），就不要记了。在本文，交换分区在/dev/sda，需要重新分区。 ","date":"2018-03-27","objectID":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/:0:2","tags":["linux"],"title":"VMware下扩展ubuntu虚拟机根目录分区","uri":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/"},{"categories":null,"content":"先关闭linux： root@ubuntu:~# shutdown -h now\r 在虚拟机设置，硬盘，实用工具下选择扩展。扩展虚拟机的最大磁盘大小，这里将磁盘设置为15G，然后重启。 重新设置分区表要删除所有的旧分区、关闭系统的swap: cruz@ubuntu:~$ sudo bash\r[sudo] password for cruz: root@ubuntu:~# free -m\rtotal used free shared buffers cached\rMem: 992 924 67 0 43 426\r-/+ buffers/cache: 454 537\rSwap: 1021 0 1021\rroot@ubuntu:~# swapoff -a\rroot@ubuntu:~# free -m\rtotal used free shared buffers cached\rMem: 992 924 67 0 43 426\r-/+ buffers/cache: 454 537\rSwap: 0 0 0\rroot@ubuntu:~# 接下来的步骤会删除/dev/sda1和/dev/sda2，一定要记住分区表的起始位置，这里是2048！ root@ubuntu:~# fdisk /dev/sda\rCommand (m for help): p\rDisk /dev/sda: 16.1 GB, 16106127360 bytes\r255 heads, 63 sectors/track, 1958 cylinders, total 31457280 sectors\rUnits = sectors of 1 * 512 = 512 bytes\rSector size (logical/physical): 512 bytes / 512 bytes\rI/O size (minimum/optimal): 512 bytes / 512 bytes\rDisk identifier: 0x00001dec\rDevice Boot Start End Blocks Id System\r/dev/sda1 * 2048 18874367 9436160 83 Linux\r/dev/sda2 18876414 20969471 1046529 5 Extended\r/dev/sda5 18876416 20969471 1046528 82 Linux swap / Solaris\rCommand (m for help): d\rPartition number (1-5): 1\rCommand (m for help): d\rPartition number (1-5): 2\rCommand (m for help): p\rDisk /dev/sda: 16.1 GB, 16106127360 bytes\r255 heads, 63 sectors/track, 1958 cylinders, total 31457280 sectors\rUnits = sectors of 1 * 512 = 512 bytes\rSector size (logical/physical): 512 bytes / 512 bytes\rI/O size (minimum/optimal): 512 bytes / 512 bytes\rDisk identifier: 0x00001dec\rDevice Boot Start End Blocks Id System\rCommand (m for help): 不要退出fdisk，接着创建新分区 Command (m for help): n\rPartition type:\rp primary (0 primary, 0 extended, 4 free)\re extended\rSelect (default p): p\rPartition number (1-4, default 1): 1\rFirst sector (2048-31457279, default 2048): Using default value 2048\rLast sector, +sectors or +size{K,M,G} (2048-31457279, default 31457279): 30410751\rCommand (m for help): n\rPartition type:\rp primary (1 primary, 0 extended, 3 free)\re extended\rSelect (default p): p\rPartition number (1-4, default 2): Using default value 2\rFirst sector (30410752-31457279, default 30410752): Using default value 30410752\rLast sector, +sectors or +size{K,M,G} (30410752-31457279, default 31457279): Using default value 31457279\r 注意记得创建交换分区，大小别搞错，这里是1046528（31457279-30410571=1046528），即要留一部分block用于创建swap。修改sda2的分区类型为82，即交换分区。 Command (m for help): p\rDisk /dev/sda: 16.1 GB, 16106127360 bytes\r255 heads, 63 sectors/track, 1958 cylinders, total 31457280 sectors\rUnits = sectors of 1 * 512 = 512 bytes\rSector size (logical/physical): 512 bytes / 512 bytes\rI/O size (minimum/optimal): 512 bytes / 512 bytes\rDisk identifier: 0x00001dec\rDevice Boot Start End Blocks Id System\r/dev/sda1 2048 30410751 15204352 83 Linux\r/dev/sda2 30410752 31457279 523264 83 Linux\rCommand (m for help): t\rPartition number (1-4): 2\rHex code (type L to list codes): 82\rChanged system type of partition 2 to 82 (Linux swap / Solaris)\rCommand (m for help): w\rThe partition table has been altered!\rCalling ioctl() to re-read partition table.\rWARNING: Re-reading the partition table failed with error 16: Device or resource busy.\rThe kernel still uses the old table. The new table will be used at\rthe next reboot or after you run partprobe(8) or kpartx(8)\rSyncing disks.\rroot@ubuntu:~# ","date":"2018-03-27","objectID":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/:0:3","tags":["linux"],"title":"VMware下扩展ubuntu虚拟机根目录分区","uri":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/"},{"categories":null,"content":"重启虚拟机： root@ubuntu:~# shutdown -r now\r 交换分区挂载需要UUID标识符。创建新的交换分区不会匹配旧的UUID，导致重启无法挂载swap分区。这里主要有两种解决方法：在/etc/fstab里写入新的UUID，或者直接将旧的UUID覆盖在新分区上，这里选择后者。 awk命令用来显示旧的UUID，dd命令确保分区没数据。 cruz@ubuntu:~$ sudo bash\r[sudo] password for cruz: root@ubuntu:~# awk '/swap/ { print $1 }' /etc/fstab\r#\rUUID=8bb62351-4436-47df-92fe-af2865f03461\rroot@ubuntu:~# swapoff -a\rroot@ubuntu:~# free -m\rtotal used free shared buffers cached\rMem: 992 695 296 0 23 325\r-/+ buffers/cache: 346 645\rSwap: 0 0 0\rroot@ubuntu:~# dd if=/dev/zero of=/dev/sda2\rdd: writing to '/dev/sda2': No space left on device\r1046529+0 records in\r1046528+0 records out\r535822336 bytes (536 MB) copied, 11.9388 s, 44.9 MB/s\rroot@ubuntu:~# mkswap -U 8bb62351-4436-47df-92fe-af2865f03461 /dev/sda2\rSetting up swapspace version 1, size = 523260 KiB\rno label, UUID=8bb62351-4436-47df-92fe-af2865f03461\rroot@ubuntu:~# swapon -a\rroot@ubuntu:~# free -m\rtotal used free shared buffers cached\rMem: 992 693 298 0 23 325\r-/+ buffers/cache: 345 646\rSwap: 510 7 503\rroot@ubuntu:~#\r ","date":"2018-03-27","objectID":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/:0:4","tags":["linux"],"title":"VMware下扩展ubuntu虚拟机根目录分区","uri":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/"},{"categories":null,"content":"最后，调整分区大小： root@ubuntu:~# df -h\rFilesystem Size Used Avail Use% Mounted on\r/dev/sda1 9.0G 2.8G 5.8G 33% /\rudev 488M 4.0K 488M 1% /dev\rtmpfs 199M 788K 198M 1% /run\rnone 5.0M 0 5.0M 0% /run/lock\rnone 497M 200K 496M 1% /run/shm\rroot@ubuntu:~# resize2fs /dev/sda1\rresize2fs 1.42 (29-Nov-2011)\rFilesystem at /dev/sda1 is mounted on /; on-line resizing required\rold_desc_blocks = 1, new_desc_blocks = 1\rPerforming an on-line resize of /dev/sda1 to 3801088 (4k) blocks.\rThe filesystem on /dev/sda1 is now 3801088 blocks long.\rroot@ubuntu:~# df -h\rFilesystem Size Used Avail Use% Mounted on\r/dev/sda1 15G 2.8G 11G 21% /\rudev 488M 4.0K 488M 1% /dev\rtmpfs 199M 788K 198M 1% /run\rnone 5.0M 0 5.0M 0% /run/lock\rnone 497M 200K 496M 1% /run/shm\rroot@ubuntu:~# ","date":"2018-03-27","objectID":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/:0:5","tags":["linux"],"title":"VMware下扩展ubuntu虚拟机根目录分区","uri":"/post/2018-3-27-vmware%E4%B8%8B%E6%89%A9%E5%B1%95ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95%E5%88%86%E5%8C%BA/"},{"categories":null,"content":"如果使用git不小心提交了一个类似debug或者.swp的临时文件，即使用git rm删除，只会向版本库中新增一条删除记录，之前提交的文件物理上还保存在版本库中，每次用git clone的时候都会下载，时间久了，这样的文件多了，就会使得整个版本库庞大无比,所以需要找到将这些文件从版本库中物理删除的办法。 ","date":"2018-03-24","objectID":"/post/2018-3-24-git%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/:0:0","tags":["git"],"title":"Git永久删除库中的文件","uri":"/post/2018-3-24-git%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"解决办法 #1. 确定文件从哪个commit引入的\rgit log --pretty=oneline --branches -- bigfile\r#2. 让git重写每一个分支, 删除bigfile\rgit filter-branch --force --index-filter \\\r 'git rm --cached --ignore-unmatch BIGFILE' \\\r --prune-empty --tag-name-filter cat -- --all\r#3. 推送修改\rgit push --all --force\r ","date":"2018-03-24","objectID":"/post/2018-3-24-git%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/:0:1","tags":["git"],"title":"Git永久删除库中的文件","uri":"/post/2018-3-24-git%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"参数说明 filter-branch 是让git重写每一个分支， --force 假如遇到冲突也让git强制执行， --index-filter 选项指定重写的时候应该执行什么命令，要执行的命令紧跟在它的后面，在这里就是git rm --cached --ignore-unmatch bigfile ，让git删除掉缓存的文件，如果有匹配的话。 --prune-empty 选项告诉git，如果因为重写导致某些commit变成了空（比如修改的文件全部被删除），那么忽略掉这个commit。 --tag-name-filter 表示对每一个tag如何重命名，重命名的命令紧跟在后面，当前的tag名会从标注输入送给后面的命令，用cat就表示保持tag名不变。 紧跟着的-- 表示分割符，最后的--all 表示对所有的文件都考虑在内。 ","date":"2018-03-24","objectID":"/post/2018-3-24-git%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/:0:2","tags":["git"],"title":"Git永久删除库中的文件","uri":"/post/2018-3-24-git%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":" iota iota是golang的一个关键字，此关键字用来声明enum的时候采用，默认从0开始，每遇到一个类似const就会重置为0。 通过开头字母大小写来实现变量和函数的公有私有。例: //共有\rvar Name string\r//私有\rvar name string\r 将数组作为函数参数进行传递时，实际传入的是该数组的副本。 由于初始化数组时无法预知定义多大的空间，就需要使用类似动态数组的结构，go语言中采用slice来实现数组的切片，类似python中的切片， slice是一个引用类型，它总是指向一个底层的array，slice的声明类似array，只是不需要长度。当引用改变其中的元素时，其他所有的引用也会相应改变。 常用内置函数: len获取长度，cap获取容量，append追加元素，并返回一个和slice一样类型的slice，copy函数从源slice的src中复制元素到目标dst，并且返回复制的元素个数。 map类似python中的字典，格式为map[keyType]valueType。map无序，必须通过key去获取。长度不固定，是一种引用类型。len函数 map不是安全的，在多个goroutine中使用时必须使用mutex lock make用于内建类型（map，slice，channel）的内存分配。new用于各种类型的内存分配。 go中switch默认相当于每个case后面都加了break。但是可以通过加fallthrough强制执行后后面的代码。 main函数和init函数，在定义时不能有任何参数和返回值。 导入包时加前缀_是为了引入该包，而不直接使用包里面的函数，只是调用包中的init函数。 interface是一组method签名的集合，可以通过interface来定义对象的一组行为。若某个对象实现了某个接口的所有方法，那么这个对象就实现了此接口。如果定义一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。空interface可以存储任何类型的数值。 element.(type)只能在switch中使用，其他地方不能使用。 golang中的反射机制，就是能够检查程序在运行时的状态。 ","date":"2018-02-28","objectID":"/post/2018-2-28-golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/:0:0","tags":["golang"],"title":"Golang基础学习整理","uri":"/post/2018-2-28-golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"},{"categories":null,"content":"函数声明 func 函数名(参数列表)(返回值列表){ //函数体 } 变量声明 var 变量名 类型 = 表达式(类型和表达式可以省略其中一个) 多个变量声明: var ( 变量名 类型 变量名 类型 ) 赋值 变量 = 表达式 _可以丢弃不需要的值 常量 const 常量名 = 表达式 const( 常量名 类型 常量名 类型 ) 批量声明的常量，除第一个外其它的常量的右边的初始化表达式都可以省略，默认使用前面常量的初始化表达式写法 iota常用语定义枚举值 总结:var 声明变量，const声明常量。声明时可以带类型。也可以不带类型，通过右推断. 位运算 \u0026 位与and (左侧和右侧都为1，则为1；否则为0) | 位或 or(左侧或右侧只要有一个为1，结果为1；都为0结果才为0) ^ 位异或 xor (相同为0，不同为1) \u0026^ 位清空and not(右侧是0，左侧数不变;右侧是1，则左侧数清零) \u003c\u003c 左移 \u003e\u003e 右移 指针 var 变量名 *类型 eg:var ptr [MAX]*int //指向数组的指针\r/*\r默认值 nil,没有NULL值\r\"\u0026\"取变量地址,“*”通过指针访问目标对象\r不能对指针做加减乘除运算\r不存在函数的指针\r*/\rvar ptr *[3]int //数组指针,保存了一个数组地址\rvar ptr [3]*int //指针数组,每元素都是指针\r type自定义类型 type 类型名字 底层类型 Switch 只有在case中明确添加fallthrough关键字，才会继续执行下一个case 不带条件表达式的Switch与if…else相同，遇到false停止 数组 var 数组名 [长度]类型\r 数组切片 var 数组切片 []类型 //声明无需定义长度\r 直接创建切片 make([]Type,len[,cap])\r 切片可遍历，可修改，不可比较 slice.copy(slice1,slice2) //slice2赋值给slice1\r```go\r包 功能\r`strings`提供了字符串查询、替换、比较、截断、拆分和合并等功能。\r`bytes`提供了很多与strings包类似的功能。因为字符串是只读的，逐步构建字符串会导致很多分配和复制，这种情况下，使用bytes.Buffer类型将会更有效。\r`strconv`提供了布尔类型、整数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。\r`unicode`提供了IsDigit、IsLetter、IsUpper和IsLower等功能，用于给字符分类。\r##### 映射\r声明:var 映射名称 map[键]值\r只是声明一个map，它的初始值是nil，也就是没有引用任何哈希表。所以不能向一个nil值的map存入元素\r创建:\r```go\rmake(map[string]int)\rmake(map[string]int,100) //初始存储能力100\rmake(map[string]int{\"key\":value,\"key\":value})\r//添加\rMap[\"key\"]=value\r//删除\rdelete(map,\"key\")\r//查看是否存在此key\rif v,ok := Map[key];!ok{\rnot key\r}\r 函数 func 函数名([形参列表])[返回值列表]{ //函数体 } 可变参数 可接收任意数量的该类型参数 func Sum(vals …int)int{ //函数体 } 错误处理 func Foo(参数列表)(res list,err error){ //… } defer通常用于 open/close, connect/disconnect, lock/unlock 等这些成对的操作, 来保证在任何情况下资源都被正确释放 结构体 type 类型名称 struct{\r//成员列表\r}\r 方法 func (变量名 类型)方法名称( [形参列表] ) [返回值列表]{\r// 方法体\r}\r 接口 interface 一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。 ","date":"2018-02-28","objectID":"/post/2018-2-28-golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/:0:1","tags":["golang"],"title":"Golang基础学习整理","uri":"/post/2018-2-28-golang%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86/"},{"categories":null,"content":" 最近老大说要在网站的后台里做一个OSS配置，后台写好，图片直接上传到云储存里面，小生不才，查资料看文章，改了N多BUG之后才做了一个基本的上传系统,下面是一些在敲代码中经历的BUG或者对一些方法的见解 ","date":"2018-02-27","objectID":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/:0:0","tags":["golang"],"title":"Golang上传文件到七牛云","uri":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/"},{"categories":null,"content":"获取 首先要获取的是七牛云官方的SDK go get -u github.com/qiniu/api.v7\r ","date":"2018-02-27","objectID":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/:0:1","tags":["golang"],"title":"Golang上传文件到七牛云","uri":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/"},{"categories":null,"content":"七牛云 七牛云没有帐号的去注册一个帐号。 个人中心有账号的直接进个人中心，去查看秘钥 AccessKey/SecretKey ","date":"2018-02-27","objectID":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/:0:2","tags":["golang"],"title":"Golang上传文件到七牛云","uri":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/"},{"categories":null,"content":"代码 一些常变量 const (\r//本地保存的文件夹名称\r upload_path string = \"/files/\"\r)\rvar (\r//BUCKET是你在存储空间的名称\r ACCESS_KEY = \"******EA09VCy5EfN_*******************\"\rSECRET_KEY = \"******-yvwcYwImN6F*******************\"\rBUCKET = \"bucket\"\r)\r WEB端代码 获取上传的文件 func uploadHandle(w http.ResponseWriter, r *http.Request) {\r//从请求当中判断方法\r if r.Method == \"GET\" {\rtmp, err := template.ParseFiles(\"templates/upload.html\")\rif err != nil {\rfmt.Println(\"模版渲染失败\")\r}\rtmp.Execute(w, nil)\r} else {\r//获取文件内容 要这样获取\r file, head, err := r.FormFile(\"file\")\rif err != nil {\rfmt.Println(err)\rreturn\r}\rdefer file.Close()\r//创建文件夹\r pwd, _ := os.Getwd()\r//文件夹存在的话会返回一个错误，可以用`_`抛出去\r err = os.Mkdir(pwd+upload_path, os.ModePerm)\rif err != nil {\rfmt.Println(\"dir is create Error\")\r}\rfW, err := os.Create(pwd + upload_path + head.Filename)\rif err != nil {\rfmt.Println(\"文件创建失败\")\rreturn\r}\rfmt.Println(*fW)\rdefer fW.Close()\r//复制文件，保存到本地\r _, err = io.Copy(fW, file)\rif err != nil {\rfmt.Println(\"文件保存失败\")\rreturn\r}\r//调用七牛上传函数\r upload_qiniu(pwd + upload_path + head.Filename)\rhttp.Redirect(w, r, \"/\", http.StatusFound)\r}\r}\r 七牛云上传函数 func upload_qiniu(filePath string) {\rkey := \"github-x.png\"\r//上传凭证,关于凭证这块大家可以去看看官方文档\r putPolicy := storage.PutPolicy{\rScope: BUCKET,\r}\rmac := qbox.NewMac(ACCESS_KEY, SECRET_KEY)\rupToken := putPolicy.UploadToken(mac)\rcfg := storage.Config{}\r//空间对应机房\r //其中关于Zone对象和机房的关系如下：\r // 机房 Zone对象\r // 华东 storage.ZoneHuadong\r // 华北 storage.ZoneHuabei\r // 华南 storage.ZoneHuanan\r // 北美 storage.ZoneBeimei\r //七牛云存储空间设置首页有存储区域\r cfg.Zone = \u0026storage.ZoneHuanan\r//不启用HTTPS域名\r cfg.UseHTTPS = false\r//不使用CND加速\r cfg.UseCdnDomains = false\r//构建上传表单对象\r formUploader := storage.NewFormUploader(\u0026cfg)\rret := storage.PutRet{}\r// 可选\r putExtra := storage.PutExtra{\rParams: map[string]string{\r\"x:name\": \"github logo\",\r},\r}\rerr := formUploader.PutFile(context.Background(), \u0026ret, upToken, key, filePath, \u0026putExtra)\rif err != nil {\rfmt.Println(err)\rreturn\r}\rfmt.Println(ret.Key, ret.Hash)\r}\r 整个代码最主要的是存储在本地的路径，然后在上传函数里面读取路径上传文件 可能还会有其他的方便，快捷的方法，我也还在摸索中，这个算是这几天学习的一个总结，后续还会修改代码，做一些扩展 完整代码地址 ","date":"2018-02-27","objectID":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/:0:3","tags":["golang"],"title":"Golang上传文件到七牛云","uri":"/post/2018-2-27-golang%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91%E5%82%A8%E5%AD%98/"},{"categories":null,"content":"一.公钥操作： 生成公钥 ssh-keygen -t rsa -C \"ma1ive@qq.com\"\r 2.查看公钥 cat ~/.ssh/id_rsa.pub\r ","date":"2018-02-22","objectID":"/post/2018-2-22-%E5%85%AC%E9%92%A5%E6%93%8D%E4%BD%9C+-git%E6%90%AD%E8%BD%BD%E6%96%B0%E9%A1%B9%E7%9B%AE/:0:1","tags":["git"],"title":"公钥操作+ git搭载新项目","uri":"/post/2018-2-22-%E5%85%AC%E9%92%A5%E6%93%8D%E4%BD%9C+-git%E6%90%AD%E8%BD%BD%E6%96%B0%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":"二.git搭载新项目： 1.在服务器建立g该项目的git目录 mkdir 项目名称\r 2.初始化该目录 git init --bare --shared\r 3.复制相似项目下的文件，至该项目下 .git clone git@git.wiapp.cn;\r 4.复制.gititnory 5.修改项目中的config.py,使项目名称保持一致 6.进入根目录下的/etc/lighttpd/conf-enabled/中，复制一个.conf 文件并进行修改 7.删除该文件下的model文件夹，复制引用同一数据库下项目中的modle 8.更改权限 9.git add 该项目文件，后git add .ignory 10.进行端口匹配 ","date":"2018-02-22","objectID":"/post/2018-2-22-%E5%85%AC%E9%92%A5%E6%93%8D%E4%BD%9C+-git%E6%90%AD%E8%BD%BD%E6%96%B0%E9%A1%B9%E7%9B%AE/:0:2","tags":["git"],"title":"公钥操作+ git搭载新项目","uri":"/post/2018-2-22-%E5%85%AC%E9%92%A5%E6%93%8D%E4%BD%9C+-git%E6%90%AD%E8%BD%BD%E6%96%B0%E9%A1%B9%E7%9B%AE/"},{"categories":null,"content":" 今天在群里看到有人发这个Gravatar为用户随机生成图像的方法,索性干脆记下来,为防止以后要用找不到 What Is Gravatar? Gravatar是Globally Recognized Avatar的缩写,是gravatar推出的一项服务，意为“全球通用头像”。如果在Gravatar的服务器上放置了你自己的头像，那么在任何支持Gravatar的blog或者留言本上留言时，只要提供你与这个头像关联的email地址，就能够显示出你的Gravatar头像来。 ","date":"2018-02-13","objectID":"/post/2018-2-13-gravatar%E4%B8%BA%E7%94%A8%E6%88%B7%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%A4%B4%E5%83%8F/:0:0","tags":["avater"],"title":"Gravatar为用户随机生成头像","uri":"/post/2018-2-13-gravatar%E4%B8%BA%E7%94%A8%E6%88%B7%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%A4%B4%E5%83%8F/"},{"categories":null,"content":"例: 只需 HTTP 请求 http://www.gravatar.com/avatar/{hash}?s=256\u0026d=identicon hash: 一个随机数 s : 图片像素 d : 图片风格(当前可选:identicon、monsterid、wavatar、retro、robohash 等) ","date":"2018-02-13","objectID":"/post/2018-2-13-gravatar%E4%B8%BA%E7%94%A8%E6%88%B7%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%A4%B4%E5%83%8F/:0:1","tags":["avater"],"title":"Gravatar为用户随机生成头像","uri":"/post/2018-2-13-gravatar%E4%B8%BA%E7%94%A8%E6%88%B7%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%A4%B4%E5%83%8F/"},{"categories":null,"content":"申请Let's Encrypt永久免费SSL证书 Let's Encrypt简介 Let's Encrypt公共且免费SSL的项目 Let's Encrypt免费SSL支持包括FireFox、Chrome在内的主流浏览器的兼容和支持，虽然目前是公测阶段，但是也有不少的用户在自有网站项目中正式使用起来。 步骤如下： 第一、安装Let's Encrypt前的准备工作 #检查系统是否安装git\rgit --version #git 安装\ryum install git\r#查看python版本,尽量保证在2.7以上\rpython -v 第二、获取Let's Encrypt免费SSL证书 //当时配置的时候,碰到好多错误,还好网上都有了解决办法,大家出错的时候可以看看letsencrypt下面的日志,里面报错内容都有,把错误尽量都解决了,再安装,不然错一次申请一次证书,次数用完,就要在等一周才能申请了. #获取letsencrypt\rgit clone https://github.com/letsencrypt/letsencrypt\r#进入letsencrypt目录\rcd letsencrypt\r#生成证书1\r//可以填两个域名，也可以填一个\r./letsencrypt-auto certonly --standalone --email your_email@address -d your_url_address -d www.your_url_address\r#生成证书2\r//我一般用这个\r./letsencrypt-auto\r1. 填入邮箱地址\r2. 选择A\r3. 选择Y\r4. 填入域名地址 //多域名用空格或者/或者,隔开\r 第三、Let's Encrypt免费SSL证书获取与应用 在完成Let's Encrypt证书的生成之后，我们会在”/etc/letsencrypt/live/your_url_address/“域名目录下有4个文件就是生成的密钥证书文件。 cert.pem - Apache服务器端证书 chain.pem - Apache根证书和中继证书 fullchain.pem - Nginx所需要ssl_certificate文件 privkey.pem - 安全证书KEY文件 如果我们使用的Nginx环境，那就需要用到fullchain.pem和privkey.pem两个证书文件，在部署Nginx的时候需要用到。在Nginx环境中，只要将对应的ssl_certificate和ssl_certificate_key路径设置成我们生成的2个文件就可以。 #打开linux配置文件，找到HTTPS 443端口配置的server,如果有以下文件就不需要再添加了，没有的话就添加上\rssl_certificate /etc/letsencrypt/live/your_url_address/fullchain.pem;\rssl_certificate_key /etc/letsencrypt/live/your_url_address/privkey.pem;\r 第四、解决Let's Encrypt免费SSL证书有效期问题 Let's Encrypt证书是有效期90天的，需要我们自己手工更新续期才可以。 手工续期命令如下：_ ./letsencrypt-auto certonly --renew-by-default --email your_email@address -d your_url_address -d www.your_url_address\r 这样我们就可以续期,当然我们也可以写一个cron脚本让他自动续期 ","date":"2018-02-11","objectID":"/post/2018-2-11-nginx%E9%83%A8%E7%BD%B2lets-encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:0:1","tags":["SSL"],"title":"Nginx部署Let's Encrypt免费SSL证书踩过的坑","uri":"/post/2018-2-11-nginx%E9%83%A8%E7%BD%B2lets-encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"从证书中删除域名 Let’s Encrypt目前并不提供从证书中删除域名的功能,所以我们只是把证书删除后重新申请. 证书每周申请数量有限,不要一直删了申请 删除证书的时候，需要删除archive中的文件和live中的符号链接，同时还需要删除证书更新的配置文件： rm -rf /etc/letsencrypt/live/www.example.com/\rrm -rf /etc/letsencrypt/archive/www.example.com/\rrm /etc/letsencrypt/renewal/www.example.com.conf\r 删除后，重新申请证书，这里给出的是webroot方式，当然你也可以用上面的方法: letsencrypt certonly --webroot -w /var/www/example -d your_url_address -d www.your_url_address\r 自动续期脚本 //这个脚本放在和let's encrypt目录同级的目录下\r#!/bin/sh\r# This script renews all the Let's Encrypt certificates with a validity \u003c 30 days\rif ! /opt/letsencrypt/letsencrypt-auto renew \u003e /var/log/letsencrypt/renew.log 2\u003e\u00261 ; then\recho Automated renewal failed:\rcat /var/log/letsencrypt/renew.log\rexit 1\rfi\r 权限 chmod +x renewCerts.sh\r cron脚本 //每个月凌晨1点运行\r0 0 1 * * /bin/sh /opt/renewCerts.sh\r 坑： 每周申请次数有限 国内服务器要放行443端口,然后重启服务器,不然访问不到,(当时国外两个服务器很快就配置好了,国内服务器一直出错出错,后来问了几个表哥,原来是阿里云要放行一下443端口.) 如果用以上第二种方法申请,nginx服务器默认的配置在删除证书文件后还存在. ","date":"2018-02-11","objectID":"/post/2018-2-11-nginx%E9%83%A8%E7%BD%B2lets-encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:0:2","tags":["SSL"],"title":"Nginx部署Let's Encrypt免费SSL证书踩过的坑","uri":"/post/2018-2-11-nginx%E9%83%A8%E7%BD%B2lets-encrypt%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"用到的包 regexp os string strconv ","date":"2018-02-09","objectID":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/:0:1","tags":["golang"],"title":"Go语言扫描硬盘查找自己需要的文件","uri":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"扫描路径函数 func getFilelist(path string,re string){\rerr:=filepath.Walk(path,func (path string,f os.FileInfo,err error) error {\rif (f==nil){return err}\rif f.IsDir(){return nil}\rfmt.Println(path)\r//正则匹配路径名和需要查找的文件名\r ok,_:=regexp.MatchString(re,path)\rif ok{\rlist=append(list,path)\r}\rWriteFile(list)\r//for k,v:=range list{\r // fmt.Println(k,\"==\u003e 查找路径:\",v)\r //}\r return nil\r})\rif err!=nil{\rfmt.Printf(\"filepath.Walk() returned %v\\n\",err)\r}\r}\r ","date":"2018-02-09","objectID":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/:0:2","tags":["golang"],"title":"Go语言扫描硬盘查找自己需要的文件","uri":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"写入文件保存 func WriteFile(file []string){\r//保存文件名\r filename:=\"./output.txt\"\r//判断文件是否存在，存在即删除\r _,err := os.Stat(filename)\rif err == nil{\ros.Remove(filename)\r}\r//打开此文件\r fd,_:=os.OpenFile(filename,os.O_RDWR|os.O_CREATE|os.O_APPEND,0644)\r//循环值并且转换类型\r for k,v:=range file{\rcontent:=strings.Join([]string{strconv.Itoa(k),\"==\u003e 查找路径:\",v,\"\\n\"},\"\")\rbuf:=[]byte(content)\rfd.Write(buf)\r}\rdefer fd.Close()\r}\r ","date":"2018-02-09","objectID":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/:0:3","tags":["golang"],"title":"Go语言扫描硬盘查找自己需要的文件","uri":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"入口函数 flag包详解 func main(){\rflag.Parse()\rroot,re:=flag.Arg(0),flag.Arg(1)\rgetFilelist(root,re)\r}\r ","date":"2018-02-09","objectID":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/:0:4","tags":["golang"],"title":"Go语言扫描硬盘查找自己需要的文件","uri":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E6%89%AB%E6%8F%8F%E7%A1%AC%E7%9B%98%E6%9F%A5%E6%89%BE%E8%87%AA%E5%B7%B1%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"主函数: //传递一个string类型，在这里我们传入需要扫描的路径\rfunc getFilelist(path string){\r//package_name:path/filepath\r //go doc filepath.Walk 查看这个函数的文档\r err:=filepath.Walk(path,func (path string,f os.FileInfo,err error) error {\r//如果f等于空，返回err错误\r if (f==nil){return err}\r//func IsDir() bool // abbreviation for Mode().IsDir()\r if f.IsDir(){return nil}\rprintln(path)\rreturn nil\r})\rif err!=nil{\rfmt.Printf(\"filepath.Walk() returned %v\\n\",err)\r}\r}\r main入口函数: flag-命令行参数解析 在写命令行程序（工具、server）时，对命令参数进行解析是常见的需求。各种语言一般都会提供解析命令行参数的方法或库，以方便程序员使用。如果命令行参数纯粹自己写代码解析，对于比较复杂的，还是挺费劲的。在 go 标准库中提供了一个包：flag，方便进行命令行解析 注:区分几个概念 命令行参数（或参数）：是指运行程序提供的参数 已定义命令行参数：是指程序中通过flag.Xxx等这种形式定义了的参数 非flag（non-flag）命令行参数（或保留的命令行参数）：后文解释 func main(){\rflag.Parse()\rroot := flag.Arg(0)\rgetFilelist(root)\r}\r 运行实例: go run filepath.go f:\\\r...\r ","date":"2018-02-09","objectID":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86demo/:0:0","tags":["golang"],"title":"Golang文件夹遍历Demo","uri":"/post/2018-2-9-go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86demo/"},{"categories":null,"content":"配置文件/etc/nginx/nginx.conf user nginx;\rworker_processes 1;\rerror_log /var/log/nginx/error.log warn;\rpid /var/run/nginx.pid;\revents {\rworker_connections 1024;\r}\rhttp {\rinclude /etc/nginx/mime.types;\rdefault_type application/octet-stream;\rlog_format main '$remote_addr [$time_local] '\r'\"$request_method $scheme://$host$request_uri $server_protocol\" '\r'$status $body_bytes_sent \"$http_referer\" '\r'\"$http_user_agent\" \"$http_x_forwarded_for\"';\raccess_log /var/log/nginx/access.log main;\rsendfile on;\r#tcp_nopush on;\rkeepalive_timeout 65;\r#gzip on;\rinclude /etc/nginx/conf.d/*.conf;\r}\r ","date":"2018-01-25","objectID":"/post/2018-01-25-nginx%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82/:0:1","tags":["Nginx"],"title":"nginx自定义日志记录完整的请求","uri":"/post/2018-01-25-nginx%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82/"},{"categories":null,"content":"容器处理 docker cp nginx:/etc/nginx/nginx.conf .\rdocker cp nginx.conf nginx:/etc/nginx/nginx.conf\r ","date":"2018-01-25","objectID":"/post/2018-01-25-nginx%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82/:0:2","tags":["Nginx"],"title":"nginx自定义日志记录完整的请求","uri":"/post/2018-01-25-nginx%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82/"},{"categories":null,"content":"通过SCL安装Ruby 2.3 jekyll需要ruby 2.1+，所以使用SCL安装ruby 2.3: # 1. Install a package with repository for your system:\r# On CentOS, install package centos-release-scl available in CentOS repository:\ryum install centos-release-scl\r# 2. Install the collection:\ryum install rh-ruby23\r# 3. Show available connections\rscl --list\r ","date":"2018-01-17","objectID":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:1","tags":["jekyll"],"title":"CentOS 7安装jekyll静态博客并通过git自动发布","uri":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":null,"content":"jekyll安装 # 1. 启用 ruby2.3环境\rscl enable rh-ruby23 bash\r# 2. 安装jekyll及插件\rgem install jekyll jekyll-paginate\r ","date":"2018-01-17","objectID":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:2","tags":["jekyll"],"title":"CentOS 7安装jekyll静态博客并通过git自动发布","uri":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":null,"content":"jekyll主题 我们使用的主题来自 huxpro.github.io，并做了定制 可以从github下载，效果图如下： ","date":"2018-01-17","objectID":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:3","tags":["jekyll"],"title":"CentOS 7安装jekyll静态博客并通过git自动发布","uri":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":null,"content":"nginx服务设置 #安装nginx\ryum install -y nginx\r#创建nginx的root目录\rmkdir -p /var/www/html\r#设置nginx根目录对于git服务可写\rchown -R git.git /var/www/html\r# /etc/nginx/nginx.conf\r#\r# For more information on configuration, see:\r# * Official English Documentation: http://nginx.org/en/docs/\r# * Official Russian Documentation: http://nginx.org/ru/docs/\ruser nginx;\rworker_processes auto;\rerror_log /var/log/nginx/error.log;\rpid /run/nginx.pid;\r# Load dynamic modules. See /usr/share/nginx/README.dynamic.\rinclude /usr/share/nginx/modules/*.conf;\revents {\rworker_connections 1024;\r}\rhttp {\rlog_format main '[$time_local] $remote_addr $server_name \"$request\" '\r'$status $body_bytes_sent \"$http_referer\" '\r'\"$http_user_agent\" \"$http_x_forwarded_for\" '\r'$upstream_addr $request_time $upstream_response_time';\r#log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\r# '$status $body_bytes_sent \"$http_referer\" '\r# '\"$http_user_agent\" \"$http_x_forwarded_for\"';\raccess_log /var/log/nginx/access.log main;\rsendfile on;\rtcp_nopush on;\rtcp_nodelay on;\rkeepalive_timeout 65;\rtypes_hash_max_size 2048;\rinclude /etc/nginx/mime.types;\rdefault_type application/octet-stream;\r# Load modular configuration files from the /etc/nginx/conf.d directory.\r# See http://nginx.org/en/docs/ngx_core_module.html#include\r# for more information.\rinclude /etc/nginx/conf.d/*.conf;\rserver {\rlisten 80 default_server;\rlisten [::]:80 default_server;\rserver_name _;\rroot /usr/share/nginx/html;\r# Load configuration files for the default server block.\rinclude /etc/nginx/default.d/*.conf;\rlocation / {\rroot /var/www/html;\r}\rerror_page 404 /404.html;\rlocation = /40x.html {\r}\rerror_page 500 502 503 504 /50x.html;\rlocation = /50x.html {\r}\r}\r}\r ","date":"2018-01-17","objectID":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:4","tags":["jekyll"],"title":"CentOS 7安装jekyll静态博客并通过git自动发布","uri":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":null,"content":"git服务设置 # 添加git用户, 并将shell设置为git-shell\ruseradd git --shell /usr/bin/git-shell\r# 创建git仓库\rmkdir -p /home/git/blog.git\rgit init --bare /home/git/blog.git\rchown -R git.git /home/git/blog.git\r#!/bin/bash\r# hooks/post-receive\rscl enable rh-ruby23 - \u003c\u003c \\EOF\rgit clone /home/git/blog.git /tmp/tmp-blog-build-repo\rjekyll build -s /tmp/tmp-blog-build-repo -d /var/www/html\rEOF\rrm -Rf /tmp/tmp-blog-build-repo\rexit\r ","date":"2018-01-17","objectID":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:5","tags":["jekyll"],"title":"CentOS 7安装jekyll静态博客并通过git自动发布","uri":"/post/2018-1-17-centos-7%E5%AE%89%E8%A3%85jekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%80%9A%E8%BF%87git%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":null,"content":"最近一直在学习爬虫方面的知识，在网上也找了很多书和视频来看，原来Web比爬虫简单多了，建议大家如果想快速上手Python的话先从Web方面入手应该会比较快。 废话不多说，这篇文章是我学爬虫来踩的第一个坑，但绝不是最后一个,俗话说在失败中学习进步。从第一个错误到成功运行也是下了蛮大的功夫。 运行成功的图 上面图片拿到排行榜前20的电影名、封面图、播放地址、主演等等 ","date":"2018-01-12","objectID":"/post/2018-1-12-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A040%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100/:0:0","tags":["Python"],"title":"(爬虫学习)40行代码爬取猫眼电影TOP100","uri":"/post/2018-1-12-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A040%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100/"},{"categories":null,"content":"正文来了 要抓取的地址 http://maoyan.com/board/4 网上有好多库和模块大家都可以利用，本小白用的是requests这个模块,用get方法获取一个地址,它返回的是一个Response对象,我们可以利用 Response.status_code来查看状态码确定网站是否访问成功 try:\rresponse=requests.get(url)\rif response.status_code==200:\rreturn response.text\rreturn None\rexcept RequestException:\rreturn None\r 个人觉得，爬虫最主要的就是对页面的分析，你要清楚你需要的是什么数据，你需要的数据是在HTML里还是JSON里或是其他地方， 在这里不得不介绍我最喜欢的chrome开发者工具，当然也有其他的，不过用惯了chrome，拿到页面按F12,打开控制台。 这个主要介绍 Network 这个功能，是我们学习爬虫要经常用的。 在《霸王别姬》这部电影按鼠标右键然后审查元素或者检查(chrome是检查)通过对页面的分析我们可以得知每部电影都在一个\u003cdd\u003e标签中包裹 它们的排名、图片、地址、演员、评分又分别在不同的标签里面,标签我们可以用beautifulsoup、xpath等Python上面的解析库和第三方库来选取 这样是最简单的，不过我这里用的是正则来匹配。可能是没被正则虐够吧,顺带给大家推荐个正则在线测试的地址正则在线测试 我们要拿到的就是图上红框里面的几个内容。 正则表达式如下: patten=re.compile('\u003cdd\u003e.*?board-index.*?\u003e(\\d+)\u003c/i\u003e.*?data-src=\"(.*?)\".*?name\"\u003e'\\\r'\u003ca.*?\u003e(.*?)\u003c/a\u003e.*?star\"\u003e(.*?)\u003c/p\u003e.*?releasetime\"\u003e(.*?)\u003c/p\u003e'\\\r'.*?integer\"\u003e(.*?)\u003c/i\u003e.*?fraction\"\u003e(.*?)\u003c/i\u003e.*?',re.S)\r .*?表示非贪婪匹配意思就是往最少的匹配，只要刚好到临界点就立马停止匹配 re.S表示.可以匹配换行符 拿到数据之后就是保存的问题，保存的时候一定要注意编码，不然拿到的数据一定会乱码 代码如下: def save_content(content):\rwith open('movie.txt','a',encoding='utf-8') as f:\rf.write(json.dumps(content,ensure_ascii=False)+'\\n')\rf.close()\r 完整代码 保存完之后就大功告成了，代码中我们可以多做优化，肯定是不会超过40行的，我们还可以添加其他功能。 在这里主要想告诉大家的是爬取一个页面的时候一定要对需要爬取的数据和页面内容好好分析，这样在编码过程中不至于一卡一顿的。 ","date":"2018-01-12","objectID":"/post/2018-1-12-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A040%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100/:0:1","tags":["Python"],"title":"(爬虫学习)40行代码爬取猫眼电影TOP100","uri":"/post/2018-1-12-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A040%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%88%AC%E5%8F%96%E7%8C%AB%E7%9C%BC%E7%94%B5%E5%BD%B1top100/"}]